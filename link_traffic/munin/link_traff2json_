#!/usr/bin/python
#%# family=auto
#%# capabilities=autoconf suggest

import socket
import sys
import os
import time
import datetime
import csv
import json

# path to configuration file 
CONFIG_FILE = '../config.cfg'
# path to data saved by link_traffic module 
SAVED_DATA = '/var/run/libtrap/saved_data'
# temporary file with downloaded data
data_temp_file = "/tmp/munin_link_traffic_data.txt"
# path to munin socket 
SOCKET_PATH = '/var/run/libtrap/munin_link_traffic'
# munin refresh interval
interval = 60
#=======================================================================
"""!@fn receiveData 
  @brief function that connects to file with saved data
  @return string of data set from socket"""
def receiveData():
   sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
   try:
      sock.connect(SOCKET_PATH)
   except socket.error as msg:
      sys.stderr.write(SOCKET_PATH + " " + str(msg) + "\n")
      sys.exit(1)

   data = ""
   while True:
      tmp = sock.recv(4096)
      data += tmp
      if tmp == "":
         break;
   
   return data
#=======================================================================
"""!@fn getData 
  @return list of strings (lines).
   There should be 2 lines: the first one with header,
   the second one with values. The data is received by
   receiveData() and stored into a cache file data_temp_file.
   If data_temp_file is new enough, data is loaded from the 
   cache file instead of calling receiveData()."""
def getData():
    current_time = time.time()
    last_time = 0
    data = ""
    try:
        last_time = os.stat(data_temp_file).st_mtime
    except:
        sys.stderr.write("%s not found or cannot read info.\n" % data_temp_file)
        pass
    if (current_time - last_time) > interval:
        data = receiveData()
        sys.stderr.write("Reading from socket\n")
        with open(data_temp_file, "w") as f:
            f.write(data)
        data = data.split("\n")
    else:
        sys.stderr.write("Reading from file\n")
        with open(data_temp_file, "r") as f:
            data = f.read()
        data = data.split("\n")
    return data
#=======================================================================
"""!@fn loadLinkConfig
  @brief function that loads links configuration, color, name,
   link number etc.
  @return list of dictionaries with link's parameters """
def loadLinkConfig():
   with open(CONFIG_FILE, 'rb') as f:
      reader = csv.reader(f)
      try:
         config = []
         for rows in reader:
            config.append({'num': rows[0],
                            'name': rows[1],
                            'ur_field': rows[2], 
                            'color': rows[3]
                           })
         return config
      except csv.Error as e:
         sys.exit('file %s, line %d: %s' % (CONFIG_FILE, reader.line_num, e))
#=======================================================================
"""! @fn getLineNum @brief function tries to find link in config file 
      based on its name 
     @return link's number"""
def getLineNum( lineName ):
   configData = loadLinkConfig()
   for items in configData:
      if items['name'] == lineName:
         return items['num']
      else:
         return None
#=======================================================================
def getTimeInfo():
   dictCurr = {} #!dictionary for current time
   dictMon = {}  #!dictionary for monitoring time
   currTime = "{:%Y-%m-%d %H:%M:%S}".format(datetime.datetime.today())
   timeStamp = time.time()

   monTime = "todo"
   monStamp = "todo"

   dictCurr = {'localtime' : currTime, 'timestamp'  : timeStamp}
   dictMon = {'interval_sec' : interval,
              'localtime' : monTime,
              'timestamp' : monStamp
             }
   return {'current' : dictCurr,
           'monitoring' : dictMon
          }
#=======================================================================
"""!@fn outputToJson
  @brief function takes configuration list of lines and data
   from socket and converts it
   to json format and prints to output 
   @return dict in json format """
def outputToJson():
   config = loadLinkConfig()
   data = getData()
   head = data[0].split(',')
   vals = data[1].split(',')
   if len(head) != len(vals):
      sys.stderr.write("wrong number of columns!!!\n")
      sys.exit(1)
   data = zip(head, vals)
   data.sort()
   dataDict = {}
   timeDict = getTimeInfo()

   # dict init name of link and its number 
   for key, val in data:
      ln = getLineNum(key.split('-')[0])
      dataDict[ln] = {"link" : ln, "link name" : key.split('-')[0]}
   # add the rest of values
   for key, val in data:
      ln = getLineNum(key.split('-')[0])
      keyStrip = key.split('-')[2]+" "+key.split('-')[1]
      dataDict[ln].update({keyStrip : val})
   # form up the final dictionary    
   dict = {'data' : dataDict, 'time' : timeDict }
   return dict
# -------------------------=== Main ===-------------------------------
jData  = outputToJson()
j = json.dumps(jData)
print(j)
  
   

